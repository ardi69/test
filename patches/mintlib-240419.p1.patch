 Makefile                  | 58 +++++++++++++++++++++++++++++++++++++++++++++--
 buildrules                |  2 +-
 configvars                |  4 ++++
 crypt/md5-crypt.c         |  2 +-
 dirent/closedir.c         |  2 +-
 dirent/readdir.c          |  2 +-
 dirent/rewinddi.c         |  2 +-
 include/bits/sched.h      |  6 ++++-
 include/errno.h           |  6 ++++-
 include/getopt_int.h      |  6 ++++-
 include/stdlib.h          |  4 ++--
 lib/Makefile              |  2 +-
 lib020/Makefile           |  2 +-
 lib020_g/Makefile         |  2 +-
 lib_g/Makefile            |  2 +-
 lib_p/Makefile            |  2 +-
 libv4e/Makefile           |  2 +-
 libv4e_g/Makefile         |  2 +-
 mintlib/EXTRAFILES        |  2 +-
 mintlib/SRCFILES          |  1 +
 mintlib/errno.c           | 13 +++++++++--
 mintlib/gensys            |  5 +++-
 mintlib/malloc.c          | 25 ++++++++++++++++----
 mintlib/malloc_int.h      |  6 ++---
 mintlib/profil-counter.h  |  2 +-
 mintlib/profil-posix.c    |  2 +-
 mintlib/realloc.c         | 15 +++++++++++-
 mintlib/spin_lock.h       | 13 +++++++++++
 misc/mntent_r.c           |  2 ++
 misc/obstack.c            |  8 +++----
 multibyte/btowc.c         |  2 +-
 multibyte/internal.c      |  2 +-
 multibyte/internal.h      |  2 +-
 multibyte/wcrtomb.c       |  2 +-
 multibyte/wcsnrtombs.c    |  2 +-
 multibyte/wcsrtombs.c     |  2 +-
 multilib.mk.in            | 23 +++++++++++++++++++
 multilib_g.mk.in          | 24 ++++++++++++++++++++
 posix/execvp.c            |  2 +-
 posix/glob.c              | 16 ++++++-------
 posix/posix_fallocate.c   |  2 +-
 posix/regex.c             | 16 ++++++++-----
 posix/sem_waitcommon.c    |  2 +-
 posix/wordexp.c           |  8 ++++---
 pwdgrp/grp.c              |  2 +-
 shadow/lckpwdf.c          |  6 ++---
 signal/sigwait.c          |  4 ++--
 socket/herror.c           |  2 +-
 socket/inet_network.c     |  3 +--
 socket/readv.c            |  6 ++---
 socket/res_debug.c        |  2 +-
 socket/res_init.c         |  4 ++++
 socket/res_mkquery.c      | 10 ++++++--
 socket/res_query.c        |  2 +-
 socket/res_send.c         |  2 +-
 socket/writev.c           |  6 ++---
 stdio/fwrite.c            |  2 +-
 stdio/lockfile.c          |  6 ++---
 stdio/obstream.c          |  2 +-
 stdio/printf_fp.c         |  2 +-
 stdio/reg-printf.c        |  3 +++
 stdio/setvbuf.c           |  1 +
 stdio/stdio-globals.c     |  2 +-
 stdio/vfprintf.c          |  4 ++--
 stdio/vfscanf.c           |  2 +-
 stdio/vsnprintf.c         |  2 +-
 stdlib/strfrom-skeleton.c |  2 +-
 stdlib/strtod.c           |  6 ++++-
 stdlib/strtol.c           |  6 ++++-
 string/strerror_r.c       |  2 ++
 string/wcscspn.c          |  2 +-
 string/wcsstr.c           |  4 ++--
 sunrpc/auth_none.c        | 10 ++++----
 sunrpc/auth_unix.c        |  2 +-
 sunrpc/clnt_raw.c         | 10 ++++----
 sunrpc/clnt_tcp.c         |  2 +-
 sunrpc/clnt_unix.c        |  2 +-
 sunrpc/key_call.c         |  4 ++--
 sunrpc/pm_getmaps.c       |  2 +-
 sunrpc/pmap_rmt.c         |  2 +-
 sunrpc/svc_auth.c         |  2 +-
 sunrpc/svc_authux.c       |  2 +-
 sunrpc/svc_raw.c          | 12 +++++-----
 sunrpc/svc_simple.c       |  4 ++--
 sunrpc/svc_tcp.c          |  4 ++--
 sunrpc/svc_udp.c          |  2 +-
 sunrpc/svc_unix.c         |  4 ++--
 sunrpc/xdr.c              |  4 ++--
 sunrpc/xdr_mem.c          |  2 +-
 sunrpc/xdr_sizeof.c       | 14 ++++++------
 sunrpc/xdr_stdio.c        |  2 +-
 time/strptime.c           |  1 +
 tz/Makefile               | 11 ++++++---
 tz/localtime.c            |  9 ++++++++
 tz/private.h              |  9 ++++++++
 unix/getcontext.S         |  2 ++
 unix/gettimeofday.c       |  2 +-
 unix/setcontext.S         |  2 ++
 unix/sigreturn.c          |  2 +-
 unix/sigvec.c             |  2 +-
 unix/swapcontext.S        |  4 ++++
 unix/sysinfo.c            |  6 +++++
 102 files changed, 389 insertions(+), 151 deletions(-)

diff --git a/Makefile b/Makefile
index 8520777..bd7dd0d 100644
--- a/Makefile
+++ b/Makefile
@@ -30,6 +30,9 @@ DIST_SUBDIRS = argp conf crypt dirent gmp include lib \
 TEST_SUBDIRS = argp crypt dirent login mintlib misc posix pwdgrp shadow signal \
   socket startup stdiio stdio stdlib string time tz unix
 
+# -mshort filtered by default
+MULTILIB_FILTER := "@mshort"
+
 ifeq ($(WITH_PROFILE_LIB), yes)
   SUBDIRS += lib_p
   DIST_SUBDIRS += lib_p
@@ -47,6 +50,8 @@ ifeq ($(WITH_020_LIB), yes)
     SUBDIRS += lib020_g
     DIST_SUBDIRS += lib020_g
   endif
+else
+  MULTILIB_FILTER = "$(MULTILIB_FILTER)|@m68020"
 endif
 
 ifeq ($(WITH_V4E_LIB), yes)
@@ -56,6 +61,12 @@ ifeq ($(WITH_V4E_LIB), yes)
     SUBDIRS += libv4e_g
     DIST_SUBDIRS += libv4e_g
   endif
+else
+  MULTILIB_FILTER = "$(MULTILIB_FILTER)|@mcpu=5475"
+endif
+
+ifneq ($(WITH_FASTCALL), yes)
+  MULTILIB_FILTER = "$(MULTILIB_FILTER)|@mfastcall"
 endif
 
 include $(srcdir)/BINFILES
@@ -63,13 +74,32 @@ include $(srcdir)/SRCFILES
 include $(srcdir)/MISCFILES
 include $(srcdir)/EXTRAFILES
 
+EXTRA_MULTILIBS := $(strip $(shell $(CC) -print-multi-lib | sed -E -e "s:\S*($(MULTILIB_FILTER))\S*::g"))
+#err := $(warning $(EXTRA_MULTILIBS))
+# filter out standards
+EXTRA_MULTILIBS := $(filter-out $(shell $(CC) -print-multi-directory);%,$(EXTRA_MULTILIBS))
+EXTRA_MULTILIBS := $(filter-out $(shell $(CC) -m68020 -print-multi-directory);%,$(EXTRA_MULTILIBS))
+EXTRA_MULTILIBS := $(filter-out $(shell $(CC) -mcpu=5475 -print-multi-directory);%,$(EXTRA_MULTILIBS))
+# only flags separated by dots e.G. .m68020-60.fastcall
+EXTRA_MULTILIBS := $(foreach LIB,$(EXTRA_MULTILIBS), $(shell echo "$(LIB)" | sed -E -e "s:^.*;::" -e "s:@:.:g" -e "s:=:@:g"))
+ifeq ($(WITH_DEBUG_LIB), yes)
+  EXTRA_MULTILIBS_G = $(foreach LIB,$(EXTRA_MULTILIBS),$(LIB).g)
+endif
+SUBDIRS += $(foreach LIB,$(EXTRA_MULTILIBS),lib$(LIB))
+DIST_SUBDIRS += $(foreach LIB,$(EXTRA_MULTILIBS),lib$(LIB))
+
+#err := $(warning EXTRA_MULTILIBS = $(EXTRA_MULTILIBS))
+#err := $(warning EXTRA_MULTILIBS_G = $(EXTRA_MULTILIBS_G))
+#err := $(warning $(foreach LIB,$(EXTRA_MULTILIBS_G),lib$(LIB)/Makefile))
+#err := $(error ende)
+
 default: all
 
 include phony
 
 all: all-here all-recursive
 
-all-here:
+all-here: $(foreach LIB,$(EXTRA_MULTILIBS),lib$(LIB)/Makefile)  $(foreach LIB,$(EXTRA_MULTILIBS_G),lib$(LIB)/Makefile)
 
 install: all-here install-recursive zoneswarning
 
@@ -84,7 +114,7 @@ install-headers: install-include-recursive
 install-man: all install-man-recursive
 
 clean:: clean-recursive
-	rm -rf .deps includepath CFILES
+	rm -rf .deps includepath CFILES $(foreach LIB,$(EXTRA_MULTILIBS),lib$(LIB)) $(foreach LIB,$(EXTRA_MULTILIBS_G),lib$(LIB))
 
 distclean:: distclean-recursive
 
@@ -250,3 +280,27 @@ mintlib.spec: mintlib.spec.in configvars
 	rm -f $@
 	sed 's,@VERSION@,$(VERSION),g' $@.in >$@
 
+
+define EXTRA_MULTILIB_TEMPLATE
+lib$(1)/Makefile : multilib.mk.in Makefile
+	echo "make Makefile $$@"
+	@if [ ! -d lib$(1) ]; then mkdir -vp lib$(1); fi
+	@sed -e "s:@SUBDIR@:lib$(1):" -e "s:@QUALIFIER@::" -e "s:@CFLAGS@:$$(subst @,=,$$(subst ., -,$(1))):g" multilib.mk.in >$$@
+	@echo "BINFILES = libc.a libiio.a" > lib$(1)/BINFILES
+	@echo "SRCFILES += BINFILES EXTRAFILES Makefile MISCFILES SRCFILES" > lib$(1)/EXTRAFILES
+	@echo "SRCFILES =" > lib$(1)/SRCFILES
+	@echo "MISCFILES =" > lib$(1)/MISCFILES
+endef
+$(foreach LIB,$(EXTRA_MULTILIBS),$(eval $(call EXTRA_MULTILIB_TEMPLATE,$(LIB))))
+
+define EXTRA_MULTILIB_G_TEMPLATE
+lib$(1)/Makefile : multilib_g.mk.in Makefile
+	echo "make Makefile $$@"
+	@if [ ! -d lib$(1) ]; then mkdir -vp lib$(1); fi
+	@sed -e "s:@SUBDIR@:lib$(1):" -e "s:@CFLAGS@:$$(subst @,=,$$(subst ., -,$(1))):g" multilib_g.mk.in >$$@
+	@echo "BINFILES = libc_g.a libiio_g.a" > lib$(1)/BINFILES
+	@echo "SRCFILES += BINFILES EXTRAFILES Makefile MISCFILES SRCFILES" > lib$(1)/EXTRAFILES
+	@echo "SRCFILES =" > lib$(1)/SRCFILES
+	@echo "MISCFILES =" > lib$(1)/MISCFILES
+endef
+$(foreach LIB,$(EXTRA_MULTILIBS_G),$(eval $(call EXTRA_MULTILIB_G_TEMPLATE,$(LIB))))
diff --git a/buildrules b/buildrules
index db359b3..b15a382 100644
--- a/buildrules
+++ b/buildrules
@@ -200,7 +200,7 @@ all-here: $(top_srcdir)/CFILES $(top_srcdir)/includepath $(CRT0OBJS) $(LIBS)
 $(top_srcdir)/includepath: $(top_srcdir)/configvars
 	@echo "Generating $@"; \
 	local= ; \
-	installdir=`$(CC) --print-search-dirs | awk '{ print $$2; exit; }'`; \
+	installdir=`$(CC) --print-search-dirs | awk '{ print $$2; exit; }' | sed -E -e 's|^(.):|/\1|' -e 's:\\\\:/:g'`; \
 	case $$installdir in /usr/local*) local=/local;; esac; \
 	echo "$${installdir}include -I$${installdir}include-fixed" >$@
 	@if [ -z "$$(<$@)" ]; then \
diff --git a/configvars b/configvars
index ca36853..bcad4ec 100644
--- a/configvars
+++ b/configvars
@@ -53,6 +53,10 @@ WITH_020_LIB=yes
 # for ColdFire V4e processors.
 WITH_V4E_LIB=yes
 
+# Uncomment this out if you want extra libraries
+# for fastcall api.
+WITH_FASTCALL=yes
+
 # Uncomment this out if you want a debuggable lib lib_g.a.
 #WITH_DEBUG_LIB=yes
 ifeq ($(ELF),yes)
diff --git a/crypt/md5-crypt.c b/crypt/md5-crypt.c
index fe17292..5274c22 100644
--- a/crypt/md5-crypt.c
+++ b/crypt/md5-crypt.c
@@ -60,7 +60,7 @@ __md5_crypt_r (const char *key, const char *salt, char *buffer, long int buflen)
     /* Skip salt prefix.  */
     salt += sizeof (md5_salt_prefix) - 1;
 
-  salt_len = MIN (strcspn (salt, "$"), 8);
+  salt_len = MIN (strcspn (salt, "$"), (size_t)8);
   key_len = strlen (key);
 
   /* Prepare for the real work.  */
diff --git a/dirent/closedir.c b/dirent/closedir.c
index 4b44c08..7655f45 100644
--- a/dirent/closedir.c
+++ b/dirent/closedir.c
@@ -38,7 +38,7 @@ __closedir(DIR *dirp)
 		__set_errno (EFAULT);
 		return -1;
 	}
-	if (dirp->handle != 0xff000000L)
+	if (dirp->handle != -0x01000000L /* == 0xff000000L */)
 		r = Dclosedir(dirp->handle);
 	else
 		r = 0;
diff --git a/dirent/readdir.c b/dirent/readdir.c
index ad5ccfd..49b6ed5 100644
--- a/dirent/readdir.c
+++ b/dirent/readdir.c
@@ -49,7 +49,7 @@ __readdir(DIR *d)
 		return NULL;
 	}
 	
-	if (d->handle != 0xff000000L)  {
+	if (d->handle != -0x01000000L /* == 0xff000000L */)  {
 		/* The directory descriptor was optained by calling Dopendir(), as
 		 * there is a valid handle.
 		 */
diff --git a/dirent/rewinddi.c b/dirent/rewinddi.c
index 022acaa..8d52c2c 100644
--- a/dirent/rewinddi.c
+++ b/dirent/rewinddi.c
@@ -35,7 +35,7 @@ rewinddir(DIR *dirp)
 		__set_errno (EFAULT);
 		return;
 	}
-	if (dirp->handle != 0xff000000L)  {
+	if (dirp->handle != -0x01000000L /* == 0xff000000L */)  {
 		(void)Drewinddir(dirp->handle);
 		dirp->buf.d_off = 0;
 		return;
diff --git a/include/bits/sched.h b/include/bits/sched.h
index 5805f4e..7c4fbe7 100644
--- a/include/bits/sched.h
+++ b/include/bits/sched.h
@@ -20,7 +20,8 @@
 #ifndef _SCHED_H
 # error "Never include <bits/sched.h> directly; use <sched.h> instead."
 #endif
-
+#ifndef _BITS_SHED_H
+#define _BITS_SHED_H
 
 /* Scheduling algorithms.  */
 #define SCHED_OTHER	0
@@ -32,3 +33,6 @@ struct sched_param
 {
   int __sched_priority;
 };
+#define __sched_param sched_param
+
+#endif /* _BITS_SHED_H */
diff --git a/include/errno.h b/include/errno.h
index e5df690..4f45563 100644
--- a/include/errno.h
+++ b/include/errno.h
@@ -39,7 +39,11 @@ __BEGIN_DECLS
    MiNTLib may require this.  */
 #define __set_errno(e) (errno = e)
 
-extern int errno;
+int *__get_p_errno(void);
+
+#define errno (*__get_p_errno())
+
+//extern int errno;
 
 # if defined(__USE_GNU)
 
diff --git a/include/getopt_int.h b/include/getopt_int.h
index 4363bb0..2f76b6c 100644
--- a/include/getopt_int.h
+++ b/include/getopt_int.h
@@ -108,7 +108,11 @@ struct _getopt_data
 
 /* The initializer is necessary to set OPTIND and OPTERR to their
    default values and to clear the initialization flag.  */
-#define _GETOPT_DATA_INITIALIZER	{ 1, 1 }
+#if defined _LIBC && defined USE_NONOPTION_FLAGS
+#  define _GETOPT_DATA_INITIALIZER	{ 1, 1, 0, 0, 0, 0, REQUIRE_ORDER, 0, 0, 0, 0, 0 }
+#else
+#  define _GETOPT_DATA_INITIALIZER	{ 1, 1, 0, 0, 0, 0, REQUIRE_ORDER, 0, 0, 0 }
+#endif
 
 extern int _getopt_internal_r (int ___argc, char *const *___argv,
 			       const char *__shortopts,
diff --git a/include/stdlib.h b/include/stdlib.h
index 47f98b6..a0c7661 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -81,14 +81,14 @@ extern long long int atoll (__const char *__nptr) __THROW;
 extern double strtod (__const char *__restrict __nptr,
 		      char **__restrict __endptr) __THROW;
 
-#ifdef	__USE_ISOC99
+/*#ifdef	__USE_ISOC99*/
 /* Likewise for `float' and `long double' sizes of floating-point numbers.  */
 extern float strtof (__const char *__restrict __nptr,
 		     char **__restrict __endptr) __THROW;
 
 extern long double strtold (__const char *__restrict __nptr,
 			    char **__restrict __endptr) __THROW;
-#endif
+/*#endif*/
 
 /* Convert a string to a long integer.  */
 extern long int strtol (__const char *__restrict __nptr,
diff --git a/lib/Makefile b/lib/Makefile
index cc1b55a..903ebda 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -15,7 +15,7 @@ csrcdir = $(top_srcdir)/src
 subdir = lib
 
 libsize = 
-instdir = 
+instdir = $(shell $(CC) -print-multi-directory)
 cflags = 
 
 default: all
diff --git a/lib020/Makefile b/lib020/Makefile
index 11363b8..e299e99 100644
--- a/lib020/Makefile
+++ b/lib020/Makefile
@@ -15,7 +15,7 @@ csrcdir = $(top_srcdir)/src
 subdir = lib020
 
 libsize = 020
-instdir = m68020-60
+instdir = $(shell $(CC) -m68020-60 -print-multi-directory)
 cflags = -m68020-60
 
 default: all
diff --git a/lib020_g/Makefile b/lib020_g/Makefile
index 9fbb139..ce7ac61 100644
--- a/lib020_g/Makefile
+++ b/lib020_g/Makefile
@@ -16,7 +16,7 @@ subdir = lib020_g
 
 qualifier = _g
 libsize = 020
-instdir = m68020-60
+instdir = $(shell $(CC) -m68020-60 -print-multi-directory)
 cflags = -m68020-60 -O -g
 nocflags = -O2 -O3 -fomit-frame-pointer -fexpensive-optimizations
 
diff --git a/lib_g/Makefile b/lib_g/Makefile
index e384d3b..02cb4a3 100644
--- a/lib_g/Makefile
+++ b/lib_g/Makefile
@@ -15,7 +15,7 @@ csrcdir = $(top_srcdir)/src
 subdir = lib_g
 
 qualifier = _g
-instdir =
+instdir = $(shell $(CC) -print-multi-directory)
 cflags = -O -g
 nocflags = -O2 -O3 -fomit-frame-pointer -fexpensive-optimizations
 
diff --git a/lib_p/Makefile b/lib_p/Makefile
index 9ff094a..ea98c2f 100644
--- a/lib_p/Makefile
+++ b/lib_p/Makefile
@@ -15,7 +15,7 @@ csrcdir = $(top_srcdir)/src
 subdir = lib_p
 
 qualifier = _p
-instdir =
+instdir = $(shell $(CC) -print-multi-directory)
 cflags = -g -pg
 nocflags = -fomit-frame-pointer
 
diff --git a/libv4e/Makefile b/libv4e/Makefile
index 92d38bb..4ace2a6 100644
--- a/libv4e/Makefile
+++ b/libv4e/Makefile
@@ -15,7 +15,7 @@ csrcdir = $(top_srcdir)/src
 subdir = libv4e
 
 libsize = v4e
-instdir = m5475
+instdir = $(shell $(CC) -mcpu=5475 -print-multi-directory)
 cflags = -mcpu=5475
 
 default: all
diff --git a/libv4e_g/Makefile b/libv4e_g/Makefile
index a76ebb0..fd54c66 100644
--- a/libv4e_g/Makefile
+++ b/libv4e_g/Makefile
@@ -16,7 +16,7 @@ subdir = libv4e_g
 
 qualifier = _g
 libsize = v4e
-instdir = m5475
+instdir = $(shell $(CC) -m5475 -print-multi-directory)
 cflags = -mcpu=5475 -O -g
 nocflags = -O2 -O3 -fomit-frame-pointer -fexpensive-optimizations
 
diff --git a/mintlib/EXTRAFILES b/mintlib/EXTRAFILES
index 4c08668..1c85267 100644
--- a/mintlib/EXTRAFILES
+++ b/mintlib/EXTRAFILES
@@ -10,7 +10,7 @@
 SRCFILES += BINFILES EXTRAFILES MISCFILES Makefile SRCFILES SYSCALLS \
 _itoa.h math_private.h math_ldbl.h atomicity.h atomicity-68020.h errbase.h \
 gensys stksiz.h sysdep.h lib.h libc-symbols.h \
-machine-gmon.h memcopy.h profil-counter.h malloc_int.h \
+machine-gmon.h memcopy.h profil-counter.h malloc_int.h spin_lock.h \
 alpha.h punct.h \
 syscalls.h syscalls.list test-assert-perr.c test-assert.c test-atexit.c \
 test-atexit.expect test-ctype.c test-ctype1.c test-ctype1.expect \
diff --git a/mintlib/SRCFILES b/mintlib/SRCFILES
index 5f5b745..0fa8c02 100644
--- a/mintlib/SRCFILES
+++ b/mintlib/SRCFILES
@@ -30,6 +30,7 @@ SRCFILES = \
 	do_chown16.c \
 	dostime.c \
 	enoent.c \
+	errno.c \
 	frexp.S \
 	ftw.c \
 	getcookie.S \
diff --git a/mintlib/errno.c b/mintlib/errno.c
index d18b85d..ecf6e31 100644
--- a/mintlib/errno.c
+++ b/mintlib/errno.c
@@ -13,6 +13,15 @@
    become very hard to override _main() in special programs such
    as drivers.  */
    
-#include <errno.h>
+//#include <errno.h>
+//
+//int errno;
 
-int errno;
+#include <compiler.h>
+
+int *__get_p_errno_single_thread_impl(void) {
+	static int errno = 0;
+	return &errno;
+}
+
+weak_alias (__get_p_errno_single_thread_impl, __get_p_errno)
diff --git a/mintlib/gensys b/mintlib/gensys
index c9993fa..e1f3a4c 100755
--- a/mintlib/gensys
+++ b/mintlib/gensys
@@ -168,7 +168,10 @@ make_array ()
           has_va_args = "no"
           
           print "static"
-          print "long _sys_" f " (int opcode, va_list args)"
+          if (length(f) == 1)
+            print "long _sys_" f " (int opcode, va_list __attribute__((unused)) args)"
+          else
+            print "long _sys_" f " (int opcode, va_list args)"
           print "{"
           for (j = 2; j <= length (f); j++)
             {
diff --git a/mintlib/malloc.c b/mintlib/malloc.c
index 46dc3e1..f5f9e1c 100644
--- a/mintlib/malloc.c
+++ b/mintlib/malloc.c
@@ -13,10 +13,10 @@
 #define NDEBUG
 #include <assert.h>
 #include <unistd.h>
-#include <osbind.h>
+#include <mintbind.h>
 #include "lib.h"
 #include "malloc_int.h"
-
+#include "spin_lock.h"
 
 /* CAUTION: use _mallocChunkSize() to tailor to your environment,
  *          do not make the default too large, as the compiler
@@ -42,6 +42,13 @@ weak_alias(__malloczero, _malloczero)
 /* linked list of free blocks struct defined in lib.h */
 struct mem_chunk _mchunk_free_list = { VAL_FREE, NULL, 0L };
 
+/* threads shares the memory. ergo each thread can use malloc
+   to make malloc thread safe we use a simple spin-lock        */
+_SPIN_MUTEX_T __malloc_mutex = _SPIN_MUTEX_INIT;
+
+#define MALLOC_SPIN_LOCK() while(__atomic_test_and_set(&__malloc_mutex, __ATOMIC_SEQ_CST)) Syield()
+#define MALLOC_SPIN_UNLOCK()  do { __malloc_mutex = 0; } while(0)
+
 
 void *
 __malloc(size_t n)
@@ -49,6 +56,8 @@ __malloc(size_t n)
 	struct mem_chunk *p, *q;
 	unsigned long sz;
 
+	_SPIN_LOCK(__malloc_mutex);
+
 	/* add a mem_chunk to required size and round up */
 	n = (n + sizeof(struct mem_chunk) + (MALLOC_ALIGNMENT - 1)) & ~(MALLOC_ALIGNMENT - 1);
 
@@ -88,8 +97,10 @@ __malloc(size_t n)
 		}
 
 		q = (struct mem_chunk * ) __sbrk(sz);
-		if (((long) q) == -1) /* can't alloc any more? */
+		if (((long) q) == -1) { /* can't alloc any more? */
+			_SPIN_UNLOCK(__malloc_mutex);
 			return NULL;
+		}
 
 		/* Note: q may be below the highest allocated chunk */
 		p = &_mchunk_free_list;
@@ -135,6 +146,8 @@ __malloc(size_t n)
 	q->next = NULL;	
 	q++; /* hand back ptr to after chunk desc */
 
+	_SPIN_UNLOCK(__malloc_mutex);
+
 	if (ZeroMallocs)
 		memset(q, 0, (size_t)(n - sizeof(struct mem_chunk)));
 
@@ -160,6 +173,8 @@ __free(void *param)
 
 	r->valid = VAL_FREE;
 
+	_SPIN_LOCK(__malloc_mutex);
+
 	/* stick it into free list, preserving ascending address order */
 	o = NULL;
 	p = &_mchunk_free_list;
@@ -203,6 +218,7 @@ __free(void *param)
 			else
 				p->next = r;
 
+			_SPIN_UNLOCK(__malloc_mutex);
 			return;
 		}
 
@@ -243,7 +259,7 @@ __free(void *param)
 		}
 	}
 	else
-        {
+	{
 		s = (struct mem_chunk * )(((long) r) + r->size);
 		if ((!_split_mem) && _heapbase != NULL &&
 		    s >= (struct mem_chunk *) _heapbase &&
@@ -260,5 +276,6 @@ __free(void *param)
 		else
 			p->next = r;
 	}
+	_SPIN_UNLOCK(__malloc_mutex);
 }
 weak_alias(__free, free)
diff --git a/mintlib/malloc_int.h b/mintlib/malloc_int.h
index 5689c76..f6d9a4f 100644
--- a/mintlib/malloc_int.h
+++ b/mintlib/malloc_int.h
@@ -6,13 +6,13 @@ struct mem_chunk
 {
 	long valid;
 #define VAL_FREE  0xf4ee0abcL
-#define VAL_ALLOC 0xa11c0abcL
-#define VAL_BORDER 0xb04d0abcL
+#define VAL_ALLOC ((long)0xa11c0abcL)
+#define VAL_BORDER ((long)0xb04d0abcL)
 
 	struct mem_chunk *next;
 	unsigned long size;
 };
-#define ALLOC_SIZE(ch) (*(long *)((char *)(ch) + sizeof(*(ch))))
+#define ALLOC_SIZE(ch) (*(unsigned long *)((char *)(ch) + sizeof(*(ch))))
 #define BORDER_EXTRA ((sizeof(struct mem_chunk) + sizeof(long) + (MALLOC_ALIGNMENT - 1)) & ~(MALLOC_ALIGNMENT - 1))
 
 /* linked list of free blocks */
diff --git a/mintlib/profil-counter.h b/mintlib/profil-counter.h
index 78eaf9d..e2047f9 100644
--- a/mintlib/profil-counter.h
+++ b/mintlib/profil-counter.h
@@ -32,7 +32,7 @@ struct mint_sigcontext
 };
 
 static void
-profil_counter (int signr, int code, struct mint_sigcontext *scp)
+profil_counter (int __attribute__((unused)) signr, int __attribute__((unused)) code, struct mint_sigcontext *scp)
 {
   profil_count ((void *) scp->sc_pc);
 }
diff --git a/mintlib/profil-posix.c b/mintlib/profil-posix.c
index eefeced..fa4d5c2 100644
--- a/mintlib/profil-posix.c
+++ b/mintlib/profil-posix.c
@@ -97,7 +97,7 @@ __profil (u_short *sample_buffer, size_t size, size_t offset, u_int scale)
   pc_offset = offset;
   pc_scale = scale;
 
-  act.sa_handler = (sighandler_t) &profil_counter;
+  act.sa_handler = (sighandler_t)(void*) &profil_counter;
   act.sa_flags = 0; //SA_RESTART;
   sigfillset (&act.sa_mask);
   if (__sigaction (SIGPROF, &act, &oact) < 0)
diff --git a/mintlib/realloc.c b/mintlib/realloc.c
index ef3aeb2..74f1091 100644
--- a/mintlib/realloc.c
+++ b/mintlib/realloc.c
@@ -9,15 +9,21 @@
 #include <string.h>
 #include <assert.h>
 #include <unistd.h>
+#include <mintbind.h> // for Syield
 #include "lib.h"
 #include "malloc_int.h"
+#include "spin_lock.h"
+
+/* threads shares the memory. ergo each thread can use malloc
+   to make malloc thread safe we use a simple spin-lock        */
+extern _SPIN_MUTEX_T __malloc_mutex;
 
 
 void *
 __realloc (void *r, size_t n)
 {
 	struct mem_chunk *p;
-	long sz;
+	unsigned long sz;
 
 	/* obscure features:
 	 * 
@@ -58,6 +64,8 @@ __realloc (void *r, size_t n)
 		/* block too small, get new one */
 		struct mem_chunk *q, *s, *t;
 
+		_SPIN_LOCK(__malloc_mutex);
+
 		q = &_mchunk_free_list;
 		t = _mchunk_free_list.next;
 		while (t && t < p)
@@ -77,11 +85,16 @@ __realloc (void *r, size_t n)
 			q->next = t->next;
 			t->size = 0;
 			t->next = NULL;
+
+			_SPIN_UNLOCK(__malloc_mutex);
+
 		}
 		else
 		{
 			void *newr;
 
+			_SPIN_UNLOCK(__malloc_mutex);
+
 			newr = __malloc(n);
 			if (newr)
 			{
diff --git a/mintlib/spin_lock.h b/mintlib/spin_lock.h
new file mode 100644
index 0000000..6ca5b44
--- /dev/null
+++ b/mintlib/spin_lock.h
@@ -0,0 +1,13 @@
+/*
+ * spin_lock
+ */
+#ifndef _SPIN_LOCK_H
+#define _SPIN_LOCK_H
+
+#define _SPIN_MUTEX_T char
+#define _SPIN_MUTEX_INIT (0)
+#define _SPIN_LOCK(SPIN_MUTEX) while(__atomic_test_and_set(&SPIN_MUTEX, __ATOMIC_SEQ_CST)) Syield()
+#define _SPIN_UNLOCK(SPIN_MUTEX)  do { SPIN_MUTEX = 0; } while(0)
+
+
+#endif /* _SPIN_LOCK_H */
diff --git a/misc/mntent_r.c b/misc/mntent_r.c
index c2927ef..dd67055 100644
--- a/misc/mntent_r.c
+++ b/misc/mntent_r.c
@@ -154,8 +154,10 @@ __getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)
     {
     case 0:
       mp->mnt_freq = 0;
+      /* fall through */
     case 1:
       mp->mnt_passno = 0;
+      /* fall through */
     case 2:
       break;
     }
diff --git a/misc/obstack.c b/misc/obstack.c
index 1105927..39d7de2 100644
--- a/misc/obstack.c
+++ b/misc/obstack.c
@@ -113,14 +113,14 @@ struct obstack *_obstack;
 #define CALL_CHUNKFUN(h, size) \
   (((h) -> use_extra_arg) \
    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
-   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
+   : (*(struct _obstack_chunk *(*) (long)) (void*) (h)->chunkfun) ((size)))
 
 #define CALL_FREEFUN(h, old_chunk) \
   do { \
     if ((h) -> use_extra_arg) \
       (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
     else \
-      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
+      (*(void (*) (void *)) (void*) (h)->freefun) ((old_chunk)); \
   } while (0)
 #else
 #define CALL_CHUNKFUN(h, size) \
@@ -172,8 +172,8 @@ _obstack_begin (struct obstack *h, int size, int alignment, POINTER (*chunkfun)
     }
 
 #if defined (__STDC__) && __STDC__
-  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
-  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
+  h->chunkfun = (struct _obstack_chunk * (*)(void *, long))(void*) chunkfun;
+  h->freefun = (void (*) (void *, struct _obstack_chunk *)) (void*)freefun;
 #else
   h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
   h->freefun = freefun;
diff --git a/multibyte/btowc.c b/multibyte/btowc.c
index 9d2c3b1..9e7cec9 100644
--- a/multibyte/btowc.c
+++ b/multibyte/btowc.c
@@ -3,5 +3,5 @@
 
 wint_t btowc(int c)
 {
-	return c<128U ? c : EOF;
+	return c<128 ? c : EOF;
 }
diff --git a/multibyte/internal.c b/multibyte/internal.c
index ab22806..083ea55 100644
--- a/multibyte/internal.c
+++ b/multibyte/internal.c
@@ -8,7 +8,7 @@
 
 #include "internal.h"
 
-#define C(x) ( x<2 ? -1 : ( R(0x80,0xc0) | x ) )
+#define C(x) ( x<2 ? (uint32_t)-1 : ( R(0x80,0xc0) | x ) )
 #define D(x) C((x+16))
 #define E(x) ( ( x==0 ? R(0xa0,0xc0) : \
                  x==0xd ? R(0x80,0xa0) : \
diff --git a/multibyte/internal.h b/multibyte/internal.h
index 1adf722..607ff5d 100644
--- a/multibyte/internal.h
+++ b/multibyte/internal.h
@@ -16,7 +16,7 @@ extern const uint32_t bittab[]; /* ATTR_LIBC_VISIBILITY; */
 #define OOB(c,b) (((((b)>>3)-0x10)|(((b)>>3)+((int32_t)(c)>>26))) & ~7)
 
 /* Interval [a,b). Either a must be 80 or b must be c0, lower 3 bits clear. */
-#define R(a,b) ((uint32_t)((a==0x80 ? 0x40-b : -a) << 23))
+#define R(a,b) (((uint32_t)((a==0x80 ? 0x40-b : -a)) << 23))
 #define FAILSTATE R(0x80,0x80)
 
 #define SA 0xc2u
diff --git a/multibyte/wcrtomb.c b/multibyte/wcrtomb.c
index a93fdd3..d20ec73 100644
--- a/multibyte/wcrtomb.c
+++ b/multibyte/wcrtomb.c
@@ -11,7 +11,7 @@
 
 #include "internal.h"
 
-size_t wcrtomb(char *__restrict s, wchar_t wc, mbstate_t *__restrict st)
+size_t wcrtomb(char *__restrict s, wchar_t wc, mbstate_t __attribute__((unused)) *__restrict st)
 {
 	if (!s) return 1;
 	if ((unsigned)wc < 0x80) {
diff --git a/multibyte/wcsnrtombs.c b/multibyte/wcsnrtombs.c
index 768d386..0e76a84 100644
--- a/multibyte/wcsnrtombs.c
+++ b/multibyte/wcsnrtombs.c
@@ -11,7 +11,7 @@
 
 #include "internal.h"
 
-size_t wcsnrtombs(char *__restrict dst, const wchar_t **__restrict wcs, size_t wn, size_t n, mbstate_t *__restrict st)
+size_t wcsnrtombs(char *__restrict dst, const wchar_t **__restrict wcs, size_t wn, size_t n, mbstate_t __attribute__((unused)) *__restrict st)
 {
 	size_t l, cnt=0, n2;
 	char *s, buf[256];
diff --git a/multibyte/wcsrtombs.c b/multibyte/wcsrtombs.c
index 042be32..343592a 100644
--- a/multibyte/wcsrtombs.c
+++ b/multibyte/wcsrtombs.c
@@ -11,7 +11,7 @@
 
 #include "internal.h"
 
-size_t wcsrtombs(char *__restrict s, const wchar_t **__restrict ws, size_t n, mbstate_t *__restrict st)
+size_t wcsrtombs(char *__restrict s, const wchar_t **__restrict ws, size_t n, mbstate_t __attribute__((unused)) *__restrict st)
 {
 	const wchar_t *ws2;
 	char buf[4];
diff --git a/multilib.mk.in b/multilib.mk.in
new file mode 100644
index 0000000..4d703fc
--- /dev/null
+++ b/multilib.mk.in
@@ -0,0 +1,23 @@
+# lib/Makefile -- MiNTLib.
+# Copyright (C) 1999, 2000 Guido Flohr <guido@freemint.de>
+#
+# This file is part of the MiNTLib project, and may only be used
+# modified and distributed under the terms of the MiNTLib project
+# license, COPYMINT.  By continuing to use, modify, or distribute
+# this file you indicate that you have read the license and
+# understand and accept it fully.
+
+SHELL = /bin/sh
+
+srcdir = .
+top_srcdir = ..
+csrcdir = $(top_srcdir)/src
+subdir = @SUBDIR@
+
+libsize = 
+instdir = $(shell $(CC) @CFLAGS@ -print-multi-directory)
+cflags = @CFLAGS@
+
+default: all
+
+include $(top_srcdir)/buildrules
diff --git a/multilib_g.mk.in b/multilib_g.mk.in
new file mode 100644
index 0000000..498b717
--- /dev/null
+++ b/multilib_g.mk.in
@@ -0,0 +1,24 @@
+# lib/Makefile -- MiNTLib.
+# Copyright (C) 1999, 2000 Guido Flohr <guido@freemint.de>
+#
+# This file is part of the MiNTLib project, and may only be used
+# modified and distributed under the terms of the MiNTLib project
+# license, COPYMINT.  By continuing to use, modify, or distribute
+# this file you indicate that you have read the license and
+# understand and accept it fully.
+
+SHELL = /bin/sh
+
+srcdir = .
+top_srcdir = ..
+csrcdir = $(top_srcdir)/src
+subdir = @SUBDIR@
+
+qualifier = _g
+instdir = $(shell $(CC) @CFLAGS@ -print-multi-directory)
+cflags = -O -g @CFLAGS@
+nocflags = -O2 -O3 -fomit-frame-pointer -fexpensive-optimizations
+
+default: all
+
+include $(top_srcdir)/buildrules
diff --git a/posix/execvp.c b/posix/execvp.c
index 64d6fec..ea4edb3 100644
--- a/posix/execvp.c
+++ b/posix/execvp.c
@@ -122,7 +122,7 @@ execvp (const char *file, char *const *argv)
 				if (__mint == 0 && **ext == '\0')
 					break;
 				/* Else fall thru'.  */
-				  
+                /* fall through */
 			default:
 				/* Some other error means we found an
 				   executable but something went wrong
diff --git a/posix/glob.c b/posix/glob.c
index e8c6f5f..898b04c 100644
--- a/posix/glob.c
+++ b/posix/glob.c
@@ -338,7 +338,7 @@ glob (const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t
   const char *dirname;
   size_t dirlen;
   int status;
-  int oldcount;
+  size_t oldcount;
 
   if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)
     {
@@ -353,7 +353,7 @@ glob (const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t
 	{
 	  /* Allocate working buffer large enough for our work.  Note that
 	    we have at least an opening and closing brace.  */
-	  int firstc;
+	  size_t firstc;
 	  char *alt_start;
 	  const char *p;
 	  const char *next;
@@ -622,7 +622,7 @@ glob (const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t
 		  struct passwd pwbuf;
 		  int save = errno;
 
-		  if (pwbuflen == -1)
+		  if (pwbuflen == (size_t)-1)
 		    /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.
 		       Try a moderate value.  */
 		    pwbuflen = 1024;
@@ -711,7 +711,7 @@ glob (const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t
 	    struct passwd pwbuf;
 	    int save = errno;
 
-	    if (buflen == -1)
+	    if (buflen == (size_t)-1)
 	      /* `sysconf' does not support _SC_GETPW_R_SIZE_MAX.  Try a
 		 moderate value.  */
 	      buflen = 1024;
@@ -822,7 +822,7 @@ glob (const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t
 	 have to glob for the directory, and then glob for
 	 the pattern in each directory found.  */
       glob_t dirs;
-      register int i;
+      register size_t i;
 
       status = glob (dirname,
 		     ((flags & (GLOB_ERR | GLOB_NOCHECK | GLOB_NOESCAPE))
@@ -972,7 +972,7 @@ glob (const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t
       if (dirlen > 0)
 	{
 	  /* Stick the directory on the front of each name.  */
-	  int ignore = oldcount;
+	  size_t ignore = oldcount;
 
 	  if ((flags & GLOB_DOOFFS) && ignore < pglob->gl_offs)
 	    ignore = pglob->gl_offs;
@@ -990,7 +990,7 @@ glob (const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t
   if (flags & GLOB_MARK)
     {
       /* Append slashes to directory names.  */
-      int i;
+      size_t i;
       struct stat st;
       for (i = oldcount; i < pglob->gl_pathc; ++i)
 	if (((flags & GLOB_ALTDIRFUNC)
@@ -1033,7 +1033,7 @@ globfree (glob_t *pglob)
 {
   if (pglob->gl_pathv != NULL)
     {
-      register int i;
+      register size_t i;
       for (i = 0; i < pglob->gl_pathc; ++i)
 	if (pglob->gl_pathv[i] != NULL)
 	  free ((__ptr_t) pglob->gl_pathv[i]);
diff --git a/posix/posix_fallocate.c b/posix/posix_fallocate.c
index 12a9ed4..9a65faf 100644
--- a/posix/posix_fallocate.c
+++ b/posix/posix_fallocate.c
@@ -35,7 +35,7 @@ posix_fallocate (int fd, __off_t offset, size_t len)
      OFFSET + LEN is too large if it is a negative value.  */
   if (offset < 0 || len == 0)
     return EINVAL;
-  if (offset + len < 0)
+  if ((__off_t)(offset + len) < 0)
     return EFBIG;
 
   /* First thing we have to make sure is that this is really a regular
diff --git a/posix/regex.c b/posix/regex.c
index 645036f..94d5235 100644
--- a/posix/regex.c
+++ b/posix/regex.c
@@ -1589,7 +1589,7 @@ static reg_errcode_t compile_range _RE_ARGS ((const char **p_ptr,
    when we use a character as a subscript we must make it unsigned.  */
 #ifndef TRANSLATE
 # define TRANSLATE(d) \
-  (translate ? (char) translate[(unsigned char) (d)] : (d))
+  (translate ? (char) translate[(unsigned char) (d)] : (char)(d))
 #endif
 
 
@@ -2018,7 +2018,9 @@ regex_compile (const char *pattern, size_t size, reg_syntax_t syntax, struct re_
           if ((syntax & RE_BK_PLUS_QM)
               || (syntax & RE_LIMITED_OPS))
             goto normal_char;
+          /* fall through */
         handle_plus:
+          /* fall through */
         case '*':
           /* If there is no previous pattern... */
           if (!laststart)
@@ -4415,6 +4417,7 @@ re_match_2_internal (struct re_pattern_buffer *bufp, const char *string1, int si
                 {
                   case jump_n:
 		    is_a_jump_n = true;
+            /* fall through */
                   case pop_failure_jump:
 		  case maybe_pop_jump:
 		  case jump:
@@ -4823,7 +4826,7 @@ re_match_2_internal (struct re_pattern_buffer *bufp, const char *string1, int si
 	      goto unconditional_jump;
 	    }
         /* Note fall through.  */
-
+        /* fall through */
 
 	/* The end of a simple repeat has a pop_failure_jump back to
            its matching on_failure_jump, where the latter will push a
@@ -4850,7 +4853,7 @@ re_match_2_internal (struct re_pattern_buffer *bufp, const char *string1, int si
             (void) pdummy;
           }
 	  /* Note fall through.  */
-
+	  /* fall through */
 	unconditional_jump:
 #ifdef _LIBC
 	  DEBUG_PRINT2 ("\n%p: ", p);
@@ -4858,7 +4861,7 @@ re_match_2_internal (struct re_pattern_buffer *bufp, const char *string1, int si
 	  DEBUG_PRINT2 ("\n0x%x: ", p);
 #endif
           /* Note fall through.  */
-
+          /* fall through */
         /* Unconditionally jump (without popping any failure points).  */
         case jump:
 	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
@@ -5139,6 +5142,7 @@ re_match_2_internal (struct re_pattern_buffer *bufp, const char *string1, int si
                 {
                 case jump_n:
                   is_a_jump_n = true;
+                  /* fall through */
                 case maybe_pop_jump:
                 case pop_failure_jump:
                 case jump:
@@ -5398,7 +5402,7 @@ common_op_match_null_string_p (unsigned char **p, unsigned char *end, register_i
 
     case set_number_at:
       p1 += 4;
-
+      /* fall through */
     default:
       /* All other opcodes mean we cannot match the empty string.  */
       return false;
@@ -5722,7 +5726,7 @@ weak_alias (__regexec, regexec)
    from either regcomp or regexec.   We don't use PREG here.  */
 
 size_t
-regerror (int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)
+regerror (int errcode, const regex_t *preg __attribute__((unused)), char *errbuf, size_t errbuf_size)
 {
   const char *msg;
   size_t msg_size;
diff --git a/posix/sem_waitcommon.c b/posix/sem_waitcommon.c
index 69d796f..090a2ea 100644
--- a/posix/sem_waitcommon.c
+++ b/posix/sem_waitcommon.c
@@ -160,7 +160,7 @@ static void __sem_wait_cleanup(void *arg)
    puts the call site into an exception region, and thus the
    cleanups get properly run.  TODO still necessary?  Other futex_wait
    users don't seem to need it.  */
-static int __attribute__((noinline)) do_futex_wait(sem_t *sem, clockid_t clockid, const struct timespec *abstime)
+static int __attribute__((noinline)) do_futex_wait(sem_t *sem, clockid_t clockid __attribute__((unused)), const struct timespec *abstime)
 {
 	int err;
 
diff --git a/posix/wordexp.c b/posix/wordexp.c
index 2fa35f4..363a761 100644
--- a/posix/wordexp.c
+++ b/posix/wordexp.c
@@ -156,7 +156,7 @@ w_addmem (char *buffer, size_t *actlen, size_t *maxlen, const char *str,
     {
       char *old_buffer = buffer;
       assert (buffer == NULL || *maxlen != 0);
-      *maxlen += MAX (2 * len, W_CHUNK);
+      *maxlen += MAX (2 * len, (size_t)W_CHUNK);
       buffer = realloc (old_buffer, 1 + *maxlen);
 
       if (buffer == NULL)
@@ -396,10 +396,10 @@ static int
 internal_function
 do_parse_glob (const char *glob_word, char **word, size_t *word_length,
 	       size_t *max_length, wordexp_t *pwordexp, const char *ifs,
-	       const char *ifs_white)
+	       const char __attribute__((unused)) *ifs_white)
 {
   int error;
-  int match;
+  size_t match;
   glob_t globbuf;
 
   error = glob (glob_word, GLOB_NOCHECK, NULL, &globbuf);
@@ -830,6 +830,7 @@ parse_arith (char **word, size_t *word_length, size_t *max_length,
 
 	case '(':
 	  ++paren_depth;
+	  /* fall through */
 	default:
 	  expr = w_addchar (expr, &expr_length, &expr_maxlen, words[*offset]);
 	  if (expr == NULL)
@@ -2040,6 +2041,7 @@ parse_backtick (char **word, size_t *word_length, size_t *max_length,
 
 	case '\'':
 	  squoting = 1 - squoting;
+	  /* fall through */
 	default:
 	  comm = w_addchar (comm, &comm_length, &comm_maxlen, words[*offset]);
 	  if (comm == NULL)
diff --git a/pwdgrp/grp.c b/pwdgrp/grp.c
index 4dcf3a0..1e6f237 100644
--- a/pwdgrp/grp.c
+++ b/pwdgrp/grp.c
@@ -66,7 +66,7 @@ struct group *getgrgid(int gid)
   setgrent();
 
   while (nextent(filep) != 0)
-    if (curentry.gr_gid == gid)
+    if (curentry.gr_gid == (__gid_t)gid)
       return(&curentry);
 
   return(NULL);
diff --git a/shadow/lckpwdf.c b/shadow/lckpwdf.c
index 05f6ab1..9325a1b 100644
--- a/shadow/lckpwdf.c
+++ b/shadow/lckpwdf.c
@@ -46,7 +46,7 @@ __libc_lock_define_initialized (static, lock)
 
 
 /* Prototypes for local functions.  */
-static void noop_handler __P ((int __sig));
+static __CDECL void noop_handler __P ((int __sig));
 
 
 /* We cannot simply return in error cases.  We have to close the file
@@ -179,8 +179,8 @@ __ulckpwdf (void)
 weak_alias (__ulckpwdf, ulckpwdf)
 
 
-static void
-noop_handler (int sig)
+static __CDECL void
+noop_handler (int sig __attribute__((unused)))
 {
   /* We simply return which makes the `fcntl' call return with an error.  */
 }
diff --git a/signal/sigwait.c b/signal/sigwait.c
index 4764c6d..49a7494 100644
--- a/signal/sigwait.c
+++ b/signal/sigwait.c
@@ -24,7 +24,7 @@
 __typeof__(sigwait) __sigwait;
 
 /* This is our dummy signal handler we use here.  */
-static void ignore_signal (int sig);
+static __CDECL void ignore_signal (int sig);
 
 /* Place where to remember which signal we got.  Please note that this
    implementation cannot be used for the threaded libc.  The
@@ -84,7 +84,7 @@ __sigwait (const sigset_t *set, int *sig)
 weak_alias (__sigwait, sigwait)
 
 
-static void
+static __CDECL void
 ignore_signal (int sig)
 {
   /* Remember the signal.  */
diff --git a/socket/herror.c b/socket/herror.c
index 5d9b4eb..bbd3c8d 100644
--- a/socket/herror.c
+++ b/socket/herror.c
@@ -18,7 +18,7 @@ herror (const char *s)
 {
 	fprintf (stderr, "%s: %s.\n",
 		(s && *s) ? s : "",
-		((u_int)h_errno < h_nerr)
+		((u_int)h_errno < (u_int)h_nerr)
 			? h_errlist[h_errno]
 			: "Unknown error");
 }
diff --git a/socket/inet_network.c b/socket/inet_network.c
index 70b55f0..eaca5a2 100644
--- a/socket/inet_network.c
+++ b/socket/inet_network.c
@@ -52,10 +52,9 @@ static char sccsid[] = "@(#)inet_network.c	5.8 (Berkeley) 2/24/91";
 in_addr_t
 inet_network (const char *cp)
 {
-	register u_long val, base, n;
+	register u_long val, base, n, i;
 	register char c;
 	u_long parts[4], *pp = parts;
-	register int i;
 
 again:
 	val = 0; base = 10;
diff --git a/socket/readv.c b/socket/readv.c
index 5c4e674..0d3385a 100644
--- a/socket/readv.c
+++ b/socket/readv.c
@@ -44,13 +44,11 @@ __readv (int fd, const struct iovec *iov, ssize_t niov)
 		
 		{
 			char *p, *_p;
-			long size, copy;
+			size_t size, copy;
 			int i;
 			
 			for (i = size = 0; i < niov; ++i) {
-				if (iov[i].iov_len >= 0)
-					size += iov[i].iov_len;
-				else {
+				if ((ssize_t)iov[i].iov_len < 0 || (ssize_t)(size += iov[i].iov_len) < 0) {
 					__set_errno (EINVAL);
 					return -1;
 				}
diff --git a/socket/res_debug.c b/socket/res_debug.c
index 932d238..07cee50 100644
--- a/socket/res_debug.c
+++ b/socket/res_debug.c
@@ -335,7 +335,7 @@ p_rr(const u_char *cp, const u_char *msg, FILE *file)
 		break;
 
 	case T_WKS:
-		if (dlen < sizeof(u_long) + 1)
+		if (dlen < (int)sizeof(u_long) + 1)
 			break;
 		memcpy(&inaddr, cp, sizeof(inaddr));
 		cp += sizeof(u_long);
diff --git a/socket/res_init.c b/socket/res_init.c
index 35534b7..a54bfec 100644
--- a/socket/res_init.c
+++ b/socket/res_init.c
@@ -64,6 +64,10 @@ struct state _res = {
 	4,                         	/* number of times to retransmit */
 	RES_DEFAULT,			/* options flags */
 	1,                         	/* number of name servers */
+	{{0,},},
+	0,
+	{0,},
+	{0,}
 };
 
 /*
diff --git a/socket/res_mkquery.c b/socket/res_mkquery.c
index ff275ce..421d6b6 100644
--- a/socket/res_mkquery.c
+++ b/socket/res_mkquery.c
@@ -46,6 +46,12 @@ static char sccsid[] = "@(#)res_mkquery.c	6.16 (Berkeley) 3/6/91";
 #include <stdio.h>
 #include <string.h>
 
+#ifdef ALLOW_UPDATES
+# define NEWRR_UNUSED
+#else
+# define NEWRR_UNUSED __attribute__((unused))
+#endif
+
 /*
  * Form all types of queries.
  * Returns the size of the result or -1.
@@ -57,7 +63,7 @@ res_mkquery(
 	int class, int type,	/* class and type of query */
 	char *data,		/* resource record data */
 	int datalen,		/* length of data */
-	struct rrec *newrr,	/* new rr for modify or append */
+	struct rrec *newrr NEWRR_UNUSED,	/* new rr for modify or append */
 	u_char *buf,		/* buffer to put query */
 	int buflen)		/* size of buffer */
 {
@@ -75,7 +81,7 @@ res_mkquery(
 	/*
 	 * Initialize header fields.
 	 */
-	if ((buf == NULL) || (buflen < sizeof(HEADER)))
+	if ((buf == NULL) || (buflen < (int)sizeof(HEADER)))
 		return(-1);
 	memset(buf, 0, sizeof(HEADER));
 	hp = (HEADER *) buf;
diff --git a/socket/res_query.c b/socket/res_query.c
index 136045a..c2b4f40 100644
--- a/socket/res_query.c
+++ b/socket/res_query.c
@@ -244,7 +244,7 @@ res_querydomain(
 		 * copy without '.' if present.
 		 */
 		n = strlen(name) - 1;
-		if (name[n] == '.' && n < sizeof(nbuf) - 1) {
+		if (name[n] == '.' && n < (int)sizeof(nbuf) - 1) {
 			memcpy(nbuf, name, n);
 			nbuf[n] = '\0';
 		} else
diff --git a/socket/res_send.c b/socket/res_send.c
index c103cd0..5ee6d09 100644
--- a/socket/res_send.c
+++ b/socket/res_send.c
@@ -148,7 +148,7 @@ res_send(const u_char *buf, int buflen, u_char *answer, int anslen)
 				msg.msg_control = 0;
 				msg.msg_controllen = 0;
 				
-				if (sendmsg(s, &msg, 0) != sizeof(len) + buflen) {
+				if (sendmsg(s, &msg, 0) != (int)sizeof(len) + buflen) {
 					terrno = errno;
 #ifdef DEBUG
 					if (_res.options & RES_DEBUG)
diff --git a/socket/writev.c b/socket/writev.c
index ca01d48..828ce03 100644
--- a/socket/writev.c
+++ b/socket/writev.c
@@ -43,14 +43,12 @@ __writev (int fd, const struct iovec *iov, ssize_t niov)
 			return r;
 		
 		{
-			long size;
+			size_t size;
 			char *p, *_p;
 			int i;
 			
 			for (i = size = 0; i < niov; ++i) {
-				if (iov[i].iov_len >= 0)
-					size += iov[i].iov_len;
-				else {
+				if ((ssize_t)iov[i].iov_len < 0 || (ssize_t)(size += iov[i].iov_len) < 0) {
 					__set_errno (EINVAL);
 					return -1;
 				}
diff --git a/stdio/fwrite.c b/stdio/fwrite.c
index 5c512b5..00cd31a 100644
--- a/stdio/fwrite.c
+++ b/stdio/fwrite.c
@@ -80,7 +80,7 @@ fwrite (const void *ptr, size_t size, size_t nmemb, FILE *stream)
     /* This is an unbuffered stream using the standard output
        buffer-flushing function, so we just do a straight write.  */
     {
-      ssize_t count = (stream->__io_funcs.__write == NULL ? to_write :
+      ssize_t count = (stream->__io_funcs.__write == NULL ? (ssize_t)to_write :
 		   (*stream->__io_funcs.__write) (stream->__cookie,
 						  (const char *) p,
 						  to_write));
diff --git a/stdio/lockfile.c b/stdio/lockfile.c
index a2a9b08..c413094 100644
--- a/stdio/lockfile.c
+++ b/stdio/lockfile.c
@@ -25,7 +25,7 @@ __typeof__(funlockfile) __internal_funlockfile;
 __typeof__(ftrylockfile) __internal_ftrylockfile;
 
 void
-__internal_flockfile (FILE *stream)
+__internal_flockfile (FILE __attribute__((unused)) *stream)
 {
   /* Do nothing.  Using this version does not do any locking.  */
 }
@@ -38,7 +38,7 @@ weak_alias (__internal_flockfile, flockfile);
 
 
 void
-__internal_funlockfile (FILE *stream)
+__internal_funlockfile (FILE __attribute__((unused)) *stream)
 {
   /* Do nothing.  Using this version does not do any locking.  */
 }
@@ -51,7 +51,7 @@ weak_alias (__internal_funlockfile, funlockfile);
 
 
 int
-__internal_ftrylockfile (FILE *stream)
+__internal_ftrylockfile (FILE __attribute__((unused)) *stream)
 {
   /* Do nothing.  Using this version does not do any locking.  */
   return 1;
diff --git a/stdio/obstream.c b/stdio/obstream.c
index 1d76f59..77466d2 100644
--- a/stdio/obstream.c
+++ b/stdio/obstream.c
@@ -27,7 +27,7 @@ static void
 grow (FILE *stream, int c)
 {
   struct obstack *obstack = (struct obstack *) stream->__cookie;
-  int size_written = (int)(stream->__target + stream->__bufp - stream->__buffer);
+  size_t size_written = (size_t)(stream->__target + stream->__bufp - stream->__buffer);
 
   /* Check if the buffer has been flushed by fseek().  */
   if (stream->__target != -1 && stream->__target > 0)
diff --git a/stdio/printf_fp.c b/stdio/printf_fp.c
index 5988ccd..111ca0d 100644
--- a/stdio/printf_fp.c
+++ b/stdio/printf_fp.c
@@ -1035,7 +1035,7 @@ __printf_fp (FILE *fp,
 
 static unsigned int
 __guess_grouping (unsigned int intdig_max, const char *grouping,
-		  wchar_t sepchar)
+		  wchar_t __attribute__((unused)) sepchar)
 {
   unsigned int groups;
 
diff --git a/stdio/reg-printf.c b/stdio/reg-printf.c
index 11ca24b..cfc2785 100644
--- a/stdio/reg-printf.c
+++ b/stdio/reg-printf.c
@@ -38,7 +38,10 @@ __register_printf_function (int spec, printf_function converter, printf_arginfo_
     }
 
   __printf_function_table = printf_funcs;
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-function-type"
   __printf_arginfo_table[spec] = (printf_arginfo_size_function *)arginfo; /* FIXME: not quite right */
+#pragma GCC diagnostic pop
   printf_funcs[spec] = converter;
 
   return 0;
diff --git a/stdio/setvbuf.c b/stdio/setvbuf.c
index a16cea6..de650ac 100644
--- a/stdio/setvbuf.c
+++ b/stdio/setvbuf.c
@@ -59,6 +59,7 @@ setvbuf (FILE *stream, char *buf, int mode, size_t size)
       break;
     case _IOLBF:	/* Line buffered.  */
       stream->__linebuf = 1;
+      /* fall through */
     case _IOFBF:	/* Fully buffered.  */
       if (size == 0)
 	{
diff --git a/stdio/stdio-globals.c b/stdio/stdio-globals.c
index 5edf18f..36932de 100644
--- a/stdio/stdio-globals.c
+++ b/stdio/stdio-globals.c
@@ -62,7 +62,7 @@ typedef struct
 		(fpos_t) -1, \
 		(fpos_t) -1, \
 		CHAIN, \
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL }; \
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, 0 }; \
 	FILE* NAME = &__##NAME;
 
 STD_STREAM(stdin, 0, STDIN_MODE, NULL);
diff --git a/stdio/vfprintf.c b/stdio/vfprintf.c
index f5a2f3b..d53e364 100644
--- a/stdio/vfprintf.c
+++ b/stdio/vfprintf.c
@@ -1107,7 +1107,7 @@ vfprintf (FILE *s, const CHAR_T *format, va_list ap)
 	else								      \
 	  {								      \
 	    len = strlen (string);					      \
-	    if (prec < len)						      \
+	    if (prec < (int)len)						      \
 	      len = prec;						      \
 	  }								      \
 									      \
@@ -2036,7 +2036,7 @@ weak_alias (_IO_vfprintf, vfprintf);
    representation of the format spec itself.  */
 static int
 printf_unknown (FILE *s, const struct printf_info *info,
-		const void *const *args)
+		__attribute__((unused)) const void *const *args)
 
 {
   int done = 0;
diff --git a/stdio/vfscanf.c b/stdio/vfscanf.c
index 7319b25..883500c 100644
--- a/stdio/vfscanf.c
+++ b/stdio/vfscanf.c
@@ -140,7 +140,7 @@
 			} while (0)
 # define input_error()	do {						      \
 			  funlockfile (s);				      \
-			  return done ?: EOF;				      \
+			  return done ?: (size_t)EOF;				      \
 			} while (0)
 # define memory_error()	do {						      \
 			  funlockfile (s);				      \
diff --git a/stdio/vsnprintf.c b/stdio/vsnprintf.c
index 4b37b0a..b185591 100644
--- a/stdio/vsnprintf.c
+++ b/stdio/vsnprintf.c
@@ -77,7 +77,7 @@ weak_alias (__vsnprintf, vsnprintf)
    will be set so that the function can report the error condition to
    the caller.  */
 static
-void __vsnprintf_output (FILE* stream, int c)
+void __vsnprintf_output (FILE* stream, int __attribute__((unused)) c)
 {
   /* We use the last character as an overflow, as we end up writing the 
    * \0 end terminator there anyway. The function will now be POSIX compliant
diff --git a/stdlib/strfrom-skeleton.c b/stdlib/strfrom-skeleton.c
index 2374797..8fa9f56 100644
--- a/stdlib/strfrom-skeleton.c
+++ b/stdlib/strfrom-skeleton.c
@@ -50,7 +50,7 @@ keep_sign_conversion (float flt)
    will be set so that the function can report the error condition to
    the caller.  */
 static
-void __vsnprintf_output (FILE* stream, int c)
+void __vsnprintf_output (FILE* stream, int c __attribute__((unused)))
 {
   /* We use the last character as an overflow, as we end up writing the 
    * \0 end terminator there anyway. The function will now be POSIX compliant
diff --git a/stdlib/strtod.c b/stdlib/strtod.c
index 3f7aa8a..ed79752 100644
--- a/stdlib/strtod.c
+++ b/stdlib/strtod.c
@@ -442,6 +442,10 @@ INTERNAL (STRTOF) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int group LOCA
 #ifndef __MINT__
 /* This file defines a function to check for correct grouping.  */
 # include "grouping.h"
+
+# define GROUP_USED
+#else
+# define GROUP_USED __attribute((unused))
 #endif
 
 
@@ -451,7 +455,7 @@ INTERNAL (STRTOF) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int group LOCA
    return 0.0.  If the number is too big to be represented, set `errno' to
    ERANGE and return HUGE_VAL with the appropriate sign.  */
 FLOAT
-INTERNAL (STRTOF) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int group LOCALE_PARAM_DECL)
+INTERNAL (STRTOF) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int group GROUP_USED LOCALE_PARAM_DECL)
 {
   int negative;			/* The sign of the number.  */
   MPN_VAR (num);		/* MP representation of the number.  */
diff --git a/stdlib/strtol.c b/stdlib/strtol.c
index 48084a9..ed9ab15 100644
--- a/stdlib/strtol.c
+++ b/stdlib/strtol.c
@@ -215,6 +215,10 @@
 #ifdef USE_NUMBER_GROUPING
 /* This file defines a function to check for correct grouping.  */
 # include "grouping.h"
+
+# define GROUP_USED
+#else
+# define GROUP_USED __attribute((unused))
 #endif
 
 
@@ -228,7 +232,7 @@ INT INTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int base,
    one converted is stored in *ENDPTR.  */
 
 INT
-INTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int base, int group LOCALE_PARAM_DECL)
+INTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int base, int group GROUP_USED LOCALE_PARAM_DECL)
 {
   int negative;
   register unsigned LONG int cutoff;
diff --git a/string/strerror_r.c b/string/strerror_r.c
index f982db4..568955a 100644
--- a/string/strerror_r.c
+++ b/string/strerror_r.c
@@ -14,6 +14,8 @@
 #pragma GCC diagnostic ignored "-Wnonnull-compare"
 #endif
 
+#pragma GCC diagnostic ignored "-Wnonnull-compare"
+
 /* The MiNTLib is actually reentrant.  The thread-safe version is
    provided here for compatibility with the GNU libc.  */
 char* __strerror_r (int errnum, char* buf, size_t bufsize)
diff --git a/string/wcscspn.c b/string/wcscspn.c
index c4e5272..214e63f 100644
--- a/string/wcscspn.c
+++ b/string/wcscspn.c
@@ -4,7 +4,7 @@ size_t wcscspn(const wchar_t *s, const wchar_t *c)
 {
 	const wchar_t *a;
 	if (!c[0]) return wcslen(s);
-	if (!c[1]) return (s=wcschr(a=s, *c)) ? s-a : wcslen(a);
+	if (!c[1]) return (s=wcschr(a=s, *c)) ? (size_t)(s-a) : wcslen(a);
 	for (a=s; *s && !wcschr(c, *s); s++);
 	return s-a;
 }
diff --git a/string/wcsstr.c b/string/wcsstr.c
index fc4bace..c40c324 100644
--- a/string/wcsstr.c
+++ b/string/wcsstr.c
@@ -68,13 +68,13 @@ static wchar_t *twoway_wcsstr(const wchar_t *h, const wchar_t *n)
 	/* Search loop */
 	for (;;) {
 		/* Update incremental end-of-haystack pointer */
-		if (z-h < l) {
+		if ((size_t)(z-h) < l) {
 			/* Fast estimate for MIN(l,63) */
 			size_t grow = l | 63;
 			const wchar_t *z2 = wmemchr(z, 0, grow);
 			if (z2) {
 				z = z2;
-				if (z-h < l) return 0;
+				if ((size_t)(z-h) < l) return 0;
 			} else z += grow;
 		}
 
diff --git a/sunrpc/auth_none.c b/sunrpc/auth_none.c
index b2f9273..3c628cc 100644
--- a/sunrpc/auth_none.c
+++ b/sunrpc/auth_none.c
@@ -95,7 +95,7 @@ authnone_create (void)
 
 /*ARGSUSED */
 static bool_t
-authnone_marshal (AUTH *client, XDR *xdrs)
+authnone_marshal (AUTH __attribute__((unused)) *client, XDR *xdrs)
 {
   struct authnone_private *ap = authnone_private;
 
@@ -105,23 +105,23 @@ authnone_marshal (AUTH *client, XDR *xdrs)
 }
 
 static void
-authnone_verf (AUTH *auth)
+authnone_verf (AUTH __attribute__((unused)) *auth)
 {
 }
 
 static bool_t
-authnone_validate (AUTH *auth, struct opaque_auth *oa)
+authnone_validate (AUTH __attribute__((unused)) *auth, struct opaque_auth __attribute__((unused)) *oa)
 {
   return TRUE;
 }
 
 static bool_t
-authnone_refresh (AUTH *auth)
+authnone_refresh (AUTH __attribute__((unused)) *auth)
 {
   return FALSE;
 }
 
 static void
-authnone_destroy (AUTH *auth)
+authnone_destroy (AUTH __attribute__((unused)) *auth)
 {
 }
diff --git a/sunrpc/auth_unix.c b/sunrpc/auth_unix.c
index b59b46f..7c22dbd 100644
--- a/sunrpc/auth_unix.c
+++ b/sunrpc/auth_unix.c
@@ -198,7 +198,7 @@ authunix_create_default (void)
  */
 
 static void
-authunix_nextverf (AUTH *auth)
+authunix_nextverf (AUTH __attribute__((unused)) *auth)
 {
   /* no action necessary */
 }
diff --git a/sunrpc/clnt_raw.c b/sunrpc/clnt_raw.c
index af939fd..cc413c1 100644
--- a/sunrpc/clnt_raw.c
+++ b/sunrpc/clnt_raw.c
@@ -134,7 +134,7 @@ clntraw_create (u_long prog, u_long vers)
 }
 
 static enum clnt_stat
-clntraw_call (CLIENT *h, u_long proc, xdrproc_t xargs, caddr_t argsp, xdrproc_t xresults, caddr_t resultsp, struct timeval timeout)
+clntraw_call (CLIENT *h, u_long proc, xdrproc_t xargs, caddr_t argsp, xdrproc_t xresults, caddr_t resultsp, struct timeval timeout __attribute__((unused)))
 {
   struct clntraw_private *clp = clntraw_private;
   XDR *xdrs = &clp->xdr_stream;
@@ -211,13 +211,13 @@ call_again:
 }
 
 static void
-clntraw_geterr (CLIENT *cl, struct rpc_err *err)
+clntraw_geterr (CLIENT __attribute__((unused)) *cl, struct rpc_err __attribute__((unused)) *err)
 {
 }
 
 
 static bool_t
-clntraw_freeres (CLIENT *cl, xdrproc_t xdr_res, caddr_t res_ptr)
+clntraw_freeres (CLIENT *cl __attribute__((unused)), xdrproc_t xdr_res, caddr_t res_ptr)
 {
   struct clntraw_private *clp = clntraw_private;
   XDR *xdrs = &clp->xdr_stream;
@@ -238,12 +238,12 @@ clntraw_abort (void)
 }
 
 static bool_t
-clntraw_control (CLIENT *cl, int i, char *c)
+clntraw_control (CLIENT __attribute__((unused)) *cl, int __attribute__((unused)) i, char __attribute__((unused)) *c)
 {
   return FALSE;
 }
 
 static void
-clntraw_destroy (CLIENT *cl)
+clntraw_destroy (CLIENT __attribute__((unused)) *cl)
 {
 }
diff --git a/sunrpc/clnt_tcp.c b/sunrpc/clnt_tcp.c
index 14b9e5c..01fa5ff 100644
--- a/sunrpc/clnt_tcp.c
+++ b/sunrpc/clnt_tcp.c
@@ -291,7 +291,7 @@ call_again:
     {
       reply_msg.acpted_rply.ar_verf = _null_auth;
       reply_msg.acpted_rply.ar_results.where = NULL;
-      reply_msg.acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;
+      reply_msg.acpted_rply.ar_results.proc = (xdrproc_t)(void*)xdr_void;
       if (!xdrrec_skiprecord (xdrs))
 	return (ct->ct_error.re_status);
       /* now decode and validate the response header */
diff --git a/sunrpc/clnt_unix.c b/sunrpc/clnt_unix.c
index 47a408c..1c2f292 100644
--- a/sunrpc/clnt_unix.c
+++ b/sunrpc/clnt_unix.c
@@ -275,7 +275,7 @@ call_again:
     {
       reply_msg.acpted_rply.ar_verf = _null_auth;
       reply_msg.acpted_rply.ar_results.where = NULL;
-      reply_msg.acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;
+      reply_msg.acpted_rply.ar_results.proc = (xdrproc_t)(void*)xdr_void;
       if (!xdrrec_skiprecord (xdrs))
 	return ct->ct_error.re_status;
       /* now decode and validate the response header */
diff --git a/sunrpc/key_call.c b/sunrpc/key_call.c
index b9cb0a6..59806ea 100644
--- a/sunrpc/key_call.c
+++ b/sunrpc/key_call.c
@@ -100,7 +100,7 @@ key_secretkey_is_set (void)
   struct key_netstres kres;
 
   memset (&kres, 0, sizeof (kres));
-  if (key_call ((u_long) KEY_NET_GET, (xdrproc_t) xdr_void, (char *) NULL,
+  if (key_call ((u_long) KEY_NET_GET, (xdrproc_t) (void*) xdr_void, (char *) NULL,
 		(xdrproc_t) xdr_key_netstres, (char *) &kres) &&
       (kres.status == KEY_SUCCESS) &&
       (kres.key_netstres_u.knet.st_priv_key[0] != 0))
@@ -218,7 +218,7 @@ key_gendes (des_block *key)
   if (client == NULL)
     return -1;
 
-  stat = clnt_call (client, KEY_GEN, (xdrproc_t) xdr_void, NULL,
+  stat = clnt_call (client, KEY_GEN, (xdrproc_t) (void*) xdr_void, NULL,
 		    (xdrproc_t) xdr_des_block, (caddr_t) key, tottimeout);
   clnt_destroy (client);
   __close (socket);
diff --git a/sunrpc/pm_getmaps.c b/sunrpc/pm_getmaps.c
index 52361f7..20ba7f2 100644
--- a/sunrpc/pm_getmaps.c
+++ b/sunrpc/pm_getmaps.c
@@ -74,7 +74,7 @@ pmap_getmaps (struct sockaddr_in *address)
 			   PMAPVERS, &socket, 50, 500);
   if (client != (CLIENT *) NULL)
     {
-      if (CLNT_CALL (client, PMAPPROC_DUMP, (xdrproc_t)xdr_void, NULL,
+      if (CLNT_CALL (client, PMAPPROC_DUMP, (xdrproc_t)(void*)xdr_void, NULL,
 		     (xdrproc_t)xdr_pmaplist, (caddr_t)&head,
 		     minutetimeout) != RPC_SUCCESS)
 	{
diff --git a/sunrpc/pmap_rmt.c b/sunrpc/pmap_rmt.c
index 5993e39..d04b681 100644
--- a/sunrpc/pmap_rmt.c
+++ b/sunrpc/pmap_rmt.c
@@ -405,7 +405,7 @@ clnt_broadcast (
 #endif
 	}
       xdrs->x_op = XDR_FREE;
-      msg.acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;
+      msg.acpted_rply.ar_results.proc = (xdrproc_t)(void*)xdr_void;
       (void) xdr_replymsg (xdrs, &msg);
       (void) (*xresults) (xdrs, resultsp);
       xdr_destroy (xdrs);
diff --git a/sunrpc/svc_auth.c b/sunrpc/svc_auth.c
index 675251b..41ddeb0 100644
--- a/sunrpc/svc_auth.c
+++ b/sunrpc/svc_auth.c
@@ -118,7 +118,7 @@ _authenticate (register struct svc_req *rqst, struct rpc_msg *msg)
 }
 
 static enum auth_stat
-_svcauth_null (struct svc_req *rqst, struct rpc_msg *msg)
+_svcauth_null (struct svc_req __attribute__((unused)) *rqst, struct rpc_msg __attribute__((unused)) *msg)
 {
   return AUTH_OK;
 }
diff --git a/sunrpc/svc_authux.c b/sunrpc/svc_authux.c
index b88c0bf..97dc825 100644
--- a/sunrpc/svc_authux.c
+++ b/sunrpc/svc_authux.c
@@ -148,7 +148,7 @@ done:
  */
 /*ARGSUSED */
 enum auth_stat
-_svcauth_short (struct svc_req *rqst, struct rpc_msg *msg)
+_svcauth_short (struct svc_req __attribute__((unused)) *rqst, struct rpc_msg __attribute__((unused)) *msg)
 {
   return AUTH_REJECTEDCRED;
 }
diff --git a/sunrpc/svc_raw.c b/sunrpc/svc_raw.c
index 756f136..5016ff0 100644
--- a/sunrpc/svc_raw.c
+++ b/sunrpc/svc_raw.c
@@ -92,13 +92,13 @@ svcraw_create (void)
 }
 
 static enum xprt_stat
-svcraw_stat (SVCXPRT *xprt)
+svcraw_stat (SVCXPRT __attribute__((unused)) *xprt)
 {
   return XPRT_IDLE;
 }
 
 static bool_t
-svcraw_recv (SVCXPRT *xprt, struct rpc_msg *msg)
+svcraw_recv (SVCXPRT *xprt __attribute__((unused)), struct rpc_msg *msg)
 {
   struct svcraw_private *srp = svcraw_private;
   XDR *xdrs;
@@ -114,7 +114,7 @@ svcraw_recv (SVCXPRT *xprt, struct rpc_msg *msg)
 }
 
 static bool_t
-svcraw_reply (SVCXPRT *xprt, struct rpc_msg *msg)
+svcraw_reply (SVCXPRT __attribute__((unused)) *xprt, struct rpc_msg *msg)
 {
   struct svcraw_private *srp = svcraw_private;
   XDR *xdrs;
@@ -131,7 +131,7 @@ svcraw_reply (SVCXPRT *xprt, struct rpc_msg *msg)
 }
 
 static bool_t
-svcraw_getargs (SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+svcraw_getargs (SVCXPRT __attribute__((unused)) *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
 {
   struct svcraw_private *srp = svcraw_private;
 
@@ -141,7 +141,7 @@ svcraw_getargs (SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
 }
 
 static bool_t
-svcraw_freeargs (SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
+svcraw_freeargs (SVCXPRT __attribute__((unused)) *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
 {
   struct svcraw_private *srp = svcraw_private;
   XDR *xdrs;
@@ -154,6 +154,6 @@ svcraw_freeargs (SVCXPRT *xprt, xdrproc_t xdr_args, caddr_t args_ptr)
 }
 
 static void
-svcraw_destroy (SVCXPRT *xprt)
+svcraw_destroy (SVCXPRT __attribute__((unused)) *xprt)
 {
 }
diff --git a/sunrpc/svc_simple.c b/sunrpc/svc_simple.c
index 021775f..8d90680 100644
--- a/sunrpc/svc_simple.c
+++ b/sunrpc/svc_simple.c
@@ -131,7 +131,7 @@ universal (struct svc_req *rqstp, SVCXPRT *transp)
    */
   if (rqstp->rq_proc == NULLPROC)
     {
-      if (svc_sendreply (transp, (xdrproc_t)xdr_void, (char *) NULL) == FALSE)
+      if (svc_sendreply (transp, (xdrproc_t)(void*)xdr_void, (char *) NULL) == FALSE)
 	{
 	  (void) fprintf (stderr, "xxx\n");
 	  exit (1);
@@ -151,7 +151,7 @@ universal (struct svc_req *rqstp, SVCXPRT *transp)
 	    return;
 	  }
 	outdata = (*(pl->p_progname)) (xdrbuf);
-	if (outdata == NULL && pl->p_outproc != (xdrproc_t)xdr_void)
+	if (outdata == NULL && pl->p_outproc != (xdrproc_t)(void*)xdr_void)
 	  /* there was an error */
 	  return;
 	if (!svc_sendreply (transp, pl->p_outproc, outdata))
diff --git a/sunrpc/svc_tcp.c b/sunrpc/svc_tcp.c
index 156ddd6..a7183d6 100644
--- a/sunrpc/svc_tcp.c
+++ b/sunrpc/svc_tcp.c
@@ -243,7 +243,7 @@ done:
 }
 
 static bool_t
-rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
+rendezvous_request (SVCXPRT __attribute__((unused)) *xprt, struct rpc_msg __attribute__((unused)) *errmsg)
 {
   int sock;
   struct tcp_rendezvous *r;
@@ -269,7 +269,7 @@ again:
 }
 
 static enum xprt_stat
-rendezvous_stat (SVCXPRT *xprt)
+rendezvous_stat (SVCXPRT __attribute__((unused)) *xprt)
 {
   return XPRT_IDLE;
 }
diff --git a/sunrpc/svc_udp.c b/sunrpc/svc_udp.c
index 8ddd578..d7eed05 100644
--- a/sunrpc/svc_udp.c
+++ b/sunrpc/svc_udp.c
@@ -209,7 +209,7 @@ svcudp_create (int sock)
 }
 
 static enum xprt_stat
-svcudp_stat (SVCXPRT *xprt)
+svcudp_stat (SVCXPRT *xprt __attribute__((unused)))
 {
 
   return XPRT_IDLE;
diff --git a/sunrpc/svc_unix.c b/sunrpc/svc_unix.c
index e7c8daf..677bd50 100644
--- a/sunrpc/svc_unix.c
+++ b/sunrpc/svc_unix.c
@@ -237,7 +237,7 @@ done:
 }
 
 static bool_t
-rendezvous_request (SVCXPRT *xprt, struct rpc_msg *errmsg)
+rendezvous_request (SVCXPRT __attribute__((unused)) *xprt, struct rpc_msg __attribute__((unused)) *errmsg)
 {
   int sock;
   struct unix_rendezvous *r;
@@ -266,7 +266,7 @@ again:
 }
 
 static enum xprt_stat
-rendezvous_stat (SVCXPRT *xprt)
+rendezvous_stat (SVCXPRT __attribute__((unused)) *xprt)
 {
   return XPRT_IDLE;
 }
diff --git a/sunrpc/xdr.c b/sunrpc/xdr.c
index 924a872..3d56cc0 100644
--- a/sunrpc/xdr.c
+++ b/sunrpc/xdr.c
@@ -548,7 +548,7 @@ xdr_bytes (XDR *xdrs, char **cpp, u_int *sizep, u_int maxsize)
 	  return FALSE;
 	}
       /* fall into ... */
-
+      /* fall through */
     case XDR_ENCODE:
       return xdr_opaque (xdrs, sp, nodesize);
 
@@ -690,7 +690,7 @@ xdr_string (XDR *xdrs, char **cpp, u_int maxsize)
 	}
       sp[size] = 0;
       /* fall into ... */
-
+      /* fall through */
     case XDR_ENCODE:
       return xdr_opaque (xdrs, sp, size);
 
diff --git a/sunrpc/xdr_mem.c b/sunrpc/xdr_mem.c
index c50a87d..4987751 100644
--- a/sunrpc/xdr_mem.c
+++ b/sunrpc/xdr_mem.c
@@ -87,7 +87,7 @@ xdrmem_create (XDR *xdrs, const caddr_t addr, u_int size, enum xdr_op op)
  */
 
 static void
-xdrmem_destroy (XDR *xdrs)
+xdrmem_destroy (XDR __attribute__((unused)) *xdrs)
 {
 }
 
diff --git a/sunrpc/xdr_sizeof.c b/sunrpc/xdr_sizeof.c
index cbf8bdf..c570ee2 100644
--- a/sunrpc/xdr_sizeof.c
+++ b/sunrpc/xdr_sizeof.c
@@ -42,7 +42,7 @@
 
 /* ARGSUSED */
 static bool_t
-x_putlong (XDR *xdrs, const long *longp)
+x_putlong (XDR *xdrs, const long __attribute__((unused)) *longp)
 {
   xdrs->x_handy += BYTES_PER_XDR_UNIT;
   return TRUE;
@@ -50,7 +50,7 @@ x_putlong (XDR *xdrs, const long *longp)
 
 /* ARGSUSED */
 static bool_t
-x_putbytes (XDR *xdrs, const char *bp, u_int len)
+x_putbytes (XDR *xdrs, const char __attribute__((unused)) *bp, u_int len)
 {
   xdrs->x_handy += len;
   return TRUE;
@@ -64,7 +64,7 @@ x_getpostn (const XDR *xdrs)
 
 /* ARGSUSED */
 static bool_t
-x_setpostn (XDR *xdrs, u_int len)
+x_setpostn (XDR __attribute__((unused)) *xdrs, u_int __attribute__((unused)) len)
 {
   /* This is not allowed */
   return FALSE;
@@ -120,7 +120,7 @@ x_destroy (XDR *xdrs)
 }
 
 static bool_t
-x_putint32 (XDR *xdrs, const int32_t *int32p)
+x_putint32 (XDR *xdrs, const int32_t __attribute__((unused)) *int32p)
 {
   xdrs->x_handy += BYTES_PER_XDR_UNIT;
   return TRUE;
@@ -146,9 +146,9 @@ xdr_sizeof (xdrproc_t func, void *data)
   ops.x_putint32 = x_putint32;
 
   /* the other harmless ones */
-  ops.x_getlong = (dummyfunc1) harmless;
-  ops.x_getbytes = (dummyfunc2) harmless;
-  ops.x_getint32 = (dummyfunc3) harmless;
+  ops.x_getlong = (dummyfunc1) (void*) harmless;
+  ops.x_getbytes = (dummyfunc2) (void*) harmless;
+  ops.x_getint32 = (dummyfunc3) (void*) harmless;
 
   x.x_op = XDR_ENCODE;
   x.x_ops = &ops;
diff --git a/sunrpc/xdr_stdio.c b/sunrpc/xdr_stdio.c
index 411cf17..204e185 100644
--- a/sunrpc/xdr_stdio.c
+++ b/sunrpc/xdr_stdio.c
@@ -157,7 +157,7 @@ xdrstdio_setpos (XDR *xdrs, u_int pos)
 }
 
 static int32_t *
-xdrstdio_inline (XDR *xdrs, int len)
+xdrstdio_inline (XDR __attribute__((unused)) *xdrs, int __attribute__((unused)) len)
 {
   /*
    * Must do some work to implement this: must insure
diff --git a/time/strptime.c b/time/strptime.c
index 38b09a5..cf1557e 100644
--- a/time/strptime.c
+++ b/time/strptime.c
@@ -44,6 +44,7 @@
 #endif
 #endif
 
+#pragma GCC diagnostic ignored "-Wtype-limits"
 
 #ifndef __P
 # if defined __GNUC__ || (defined __STDC__ && __STDC__)
diff --git a/tz/Makefile b/tz/Makefile
index b6e5b66..8734cab 100644
--- a/tz/Makefile
+++ b/tz/Makefile
@@ -88,6 +88,11 @@ ifeq ($(CROSS),yes)
 zic = ./zic_for_build$(EXEEXT_FOR_BUILD)
 OBJS_FOR_BUILD = localtime_for_build.o asctime_for_build.o strftime_for_build.o
 
+zic_for_build$(EXEEXT_FOR_BUILD): CFLAGS_FOR_BUILD += $(shell echo "#include <sys/wait.h>" | $(CC_FOR_BUILD) -xc -S - -o /dev/null 2>/dev/null || echo "-DHAVE_SYS_WAIT_H=0")
+zic_for_build$(EXEEXT_FOR_BUILD): CFLAGS_FOR_BUILD += $(shell echo "#include <direct.h>" | $(CC_FOR_BUILD) -xc -E - -o /dev/null 2>/dev/null && echo "-DHAVE_DIRECT_H")
+zic_for_build$(EXEEXT_FOR_BUILD): CFLAGS_FOR_BUILD += $(shell echo -e "#include <unistd.h>\nvoid *p=link" | $(CC_FOR_BUILD) -xc -S - -o /dev/null 2>/dev/null || echo "-DHAVE_LINK=0")
+zic_for_build$(EXEEXT_FOR_BUILD): CFLAGS_FOR_BUILD += $(shell echo -e "#include <unistd.h>\nvoid *p=symlink" | $(CC_FOR_BUILD) -xc -S - -o /dev/null 2>/dev/null || echo "-DHAVE_SYMLINK=0")
+
 zic_for_build$(EXEEXT_FOR_BUILD): zic_for_build.o $(OBJS_FOR_BUILD)
 	$(AM_V_LD)$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) -o $@ $^
 zdump = ./zdump_for_build$(EXEEXT_FOR_BUILD)
@@ -269,13 +274,13 @@ uninstall-man:
 	done
 	
 zdump: $(TZDOBJS) $(CRT0) $(libs)
-	$(AM_V_LD)$(CC) $(LDFLAGS) $(TESTLDFLAGS) $(CRT0) $(TZDOBJS) -o $@ $(LIBS)
+	$(AM_V_LD)$(CC) $(LDFLAGS) -Wl,--keep-elf $(TESTLDFLAGS) $(CRT0) $(TZDOBJS) -o $@ $(LIBS)
 
 zic: $(TZCOBJS) $(CRT0) $(libs)
-	$(AM_V_LD)$(CC) $(LDFLAGS) $(TESTLDFLAGS) $(CRT0) $(TZCOBJS) -o $@ $(LIBS)
+	$(AM_V_LD)$(CC) $(LDFLAGS) -Wl,--keep-elf $(TESTLDFLAGS) $(CRT0) $(TZCOBJS) -o $@ $(LIBS)
 
 tzinit: $(TZIOBJS) $(CRT0) $(libs)
-	$(AM_V_LD)$(CC) $(LDFLAGS) $(TESTLDFLAGS) $(CRT0) $(TZIOBJS) -o $@ $(LIBS)
+	$(AM_V_LD)$(CC) $(LDFLAGS) -Wl,--keep-elf $(TESTLDFLAGS) $(CRT0) $(TZIOBJS) -o $@ $(LIBS)
 
 tzredo-posix_only: $(zic) $(TDATA)
 	$(ZIC) -d $(DESTDIR)$(TZDIR) -L /dev/null $(TDATA)
diff --git a/tz/localtime.c b/tz/localtime.c
index 1172a75..77a8069 100644
--- a/tz/localtime.c
+++ b/tz/localtime.c
@@ -725,6 +725,8 @@ static int tzloadbody(const char *name, struct state *sp, int doextend, union lo
 		return EINVAL;
 	if (sp->timecnt > 1)
 	{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic warning "-Wtype-limits"
 		if (sp->ats[0] <= TIME_T_MAX - SECSPERREPEAT)
 		{
 			time_t repeatat = sp->ats[0] + SECSPERREPEAT;
@@ -753,6 +755,7 @@ static int tzloadbody(const char *name, struct state *sp, int doextend, union lo
 				}
 			}
 		}
+#pragma GCC diagnostic pop
 	}
 
 	/* Infer sp->defaulttype from the data.  Although this default
@@ -1192,7 +1195,10 @@ static int tzparse(const char *name, struct state *sp, struct state *basep)
 	if (name == NULL)
 		return FALSE;
 	charcnt = stdlen + 1;
+#pragma GCC diagnostic push
+#pragma GCC diagnostic warning "-Wsign-compare"
 	if (sizeof sp->chars < charcnt)
+#pragma GCC diagnostic pop
 		return FALSE;
 	if (basep)
 	{
@@ -1245,7 +1251,10 @@ static int tzparse(const char *name, struct state *sp, struct state *basep)
 		if (dstlen == 0)
 			return FALSE;
 		charcnt += dstlen + 1;
+#pragma GCC diagnostic push
+#pragma GCC diagnostic warning "-Wsign-compare"
 		if (sizeof sp->chars < charcnt)
+#pragma GCC diagnostic pop
 			return FALSE;
 		if (*name != '\0' && *name != ',' && *name != ';')
 		{
diff --git a/tz/private.h b/tz/private.h
index 0bd956f..5cdf6a9 100644
--- a/tz/private.h
+++ b/tz/private.h
@@ -422,6 +422,15 @@ typedef unsigned long uintmax_t;
 # define ckd_mul(r, a, b) __builtin_mul_overflow(a, b, r)
 #endif
 
+#ifndef __GNUC_PREREQ
+#  if defined __GNUC__ && defined __GNUC_MINOR__
+#   define __GNUC_PREREQ(maj, min) \
+      ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+#  else
+#    define __GNUC_PREREQ(maj, min) 0
+#  endif
+#endif
+
 #if __GNUC_PREREQ(2, 96)
 # define ATTRIBUTE_CONST __attribute__ ((const))
 # define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
diff --git a/unix/getcontext.S b/unix/getcontext.S
index d67d7e3..7bcb31b 100644
--- a/unix/getcontext.S
+++ b/unix/getcontext.S
@@ -34,6 +34,7 @@ ENTRY(__getcontext)
 	lea	4(%sp), %a1
 	move.l	%a1, oSP(%a0)
 	move.l	(%sp), oPC(%a0)
+#ifndef __SOFTFP__ /* don't touch fp-register with -msoft-float
 #ifdef __mcoldfire__
 	fmove.l %fpcr, oFPREGS(%a0)
 	fmove.l %fpsr, oFPREGS+4(%a0)
@@ -44,6 +45,7 @@ ENTRY(__getcontext)
 	fmovem.l %fpsr/%fpcr/%fpiar, oFPREGS(%a0)
 	fmovem.x %fp2-%fp7, oFP2(%a0)
 #endif
+#endif
 #endif
 	cfi_def_cfa (%a0, 0)
 	cfi_offset (%d2, oGREGS+2*4)
diff --git a/unix/gettimeofday.c b/unix/gettimeofday.c
index 2ac2b3b..e7501ac 100644
--- a/unix/gettimeofday.c
+++ b/unix/gettimeofday.c
@@ -62,7 +62,7 @@ __gettimeofday (struct timeval *tp, struct timezone *tzp)
   if (tp != NULL) {
     tp->tv_sec = mktime (&now);
     tp->tv_usec = (clock() * (1000000UL / CLOCKS_PER_SEC)) % 2000000UL;
-    if (tp->tv_usec >= 1000000UL)
+    if (tp->tv_usec >= 1000000L)
     {
       tp->tv_usec -= 1000000UL;
       tp->tv_sec++;
diff --git a/unix/setcontext.S b/unix/setcontext.S
index 172a766..03954f3 100644
--- a/unix/setcontext.S
+++ b/unix/setcontext.S
@@ -70,6 +70,7 @@ ENTRY(__setcontext)
 	/* Load the values of all the preserved registers (except SP).  */
 	movem.l	oGREGS+2*4(%a0), %d2-%d7
 	movem.l	oGREGS+10*4(%a0), %a2-%a6
+#ifndef __SOFTFP__ /* don't touch fp-register with -msoft-float
 #ifdef __mcoldfire__
 	fmove.l oFPREGS(%a0), %fpcr
 	fmove.l oFPREGS+4(%a0), %fpsr
@@ -80,6 +81,7 @@ ENTRY(__setcontext)
 	fmovem.l oFPREGS(%a0), %fpsr/%fpcr/%fpiar
 	fmovem.x oFP2(%a0), %fp2-%fp7
 #endif
+#endif
 #endif
 	clr.l	%d0
 
diff --git a/unix/sigreturn.c b/unix/sigreturn.c
index eaf180e..bf45941 100644
--- a/unix/sigreturn.c
+++ b/unix/sigreturn.c
@@ -14,7 +14,7 @@
 __typeof__(sigreturn) __sigreturn;
 
 void
-__sigreturn (struct sigcontext* __unused)
+__sigreturn (struct sigcontext __attribute__((unused)) * __unused)
 {
 	Psigreturn ();
 }
diff --git a/unix/sigvec.c b/unix/sigvec.c
index 238eb80..8036c7f 100644
--- a/unix/sigvec.c
+++ b/unix/sigvec.c
@@ -51,7 +51,7 @@ __sigvec (int sig, const struct sigvec *sv, struct sigvec *osv)
 weak_alias (__sigvec, sigvec)
 
 int
-__siginterrupt (int sig, int fail)
+__siginterrupt (int __attribute__((unused)) sig, int fail)
 {
 	if (fail)
 	  {
diff --git a/unix/swapcontext.S b/unix/swapcontext.S
index 464633c..3286891 100644
--- a/unix/swapcontext.S
+++ b/unix/swapcontext.S
@@ -33,6 +33,7 @@ ENTRY(__swapcontext)
 	lea	4(%sp), %a1
 	move.l	%a1, oSP(%a0)
 	move.l	(%sp), oPC(%a0)
+#ifndef __SOFTFP__ /* don't touch fp-register with -msoft-float
 #ifdef __mcoldfire__
 	fmove.l %fpcr, oFPREGS(%a0)
 	fmove.l %fpsr, oFPREGS+4(%a0)
@@ -43,6 +44,7 @@ ENTRY(__swapcontext)
 	fmovem.l %fpsr/%fpcr/%fpiar, oFPREGS(%a0)
 	fmovem.x %fp2-%fp7, oFP2(%a0)
 #endif
+#endif
 #endif
 	cfi_def_cfa (%a0, 0)
 	cfi_offset (%d2, oGREGS+2*4)
@@ -98,6 +100,7 @@ ENTRY(__swapcontext)
 	/* Load the values of all the preserved registers (except SP).  */
 	movem.l	oGREGS+2*4(%a1), %d2-%d7
 	movem.l	oGREGS+10*4(%a1), %a2-%a6
+#ifndef __SOFTFP__ /* don't touch fp-register with -msoft-float
 #ifdef __mcoldfire__
 	fmove.l oFPREGS(%a1), %fpcr
 	fmove.l oFPREGS+4(%a1), %fpsr
@@ -108,6 +111,7 @@ ENTRY(__swapcontext)
 	fmovem.l oFPREGS(%a1), %fpsr/%fpcr/%fpiar
 	fmovem.x oFP2(%a1), %fp2-%fp7
 #endif
+#endif
 #endif
 
 	/* Clear D0 to indicate success.  */
diff --git a/unix/sysinfo.c b/unix/sysinfo.c
index 37f017b..b9c4470 100644
--- a/unix/sysinfo.c
+++ b/unix/sysinfo.c
@@ -286,13 +286,19 @@ si_version (char* buf, long bufsize)
 			if (Super(1L) == 0L)
 			{
 				save_stk = (void *) Super (0L);
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Warray-bounds="
 				sysbase = *((long int**) 0x000004f2);
+#pragma GCC diagnostic pop
 				tosversion = *sysbase;
 				(void) SuperToUser ((void*) save_stk);
 			}
 			else
 			{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Warray-bounds="
 				sysbase = *((long int**) 0x000004f2);
+#pragma GCC diagnostic pop
 				tosversion = *sysbase;
 			}
 		}
